import os
from dataclasses import dataclass

import numpy as np
from scipy.optimize import linear_sum_assignment
from sklearn.metrics.pairwise import cosine_similarity


@dataclass
class SimilarityArg:
    """
    A data class that stores arguments required for similarity computation.

    Attributes:
            final_names (list): List containing the names of the files to be compared.
            average_node_embeddings (list): List containing node embeddings for each file.
            average_edge_embeddings (list): List containing edge embeddings for each file.
            average_graph_embeddings (list): List containing graph embeddings for each file.
            directory_name (str): Name of the directory where the results will be saved.
            do_hungarian (bool): Whether to use Hungarian algorithm or Greedy algorithm.
            make_padding (bool): Whether to apply padding in case of size mismatch between matrices
            i (int): Index of current computation.
    """
    final_names: list
    average_node_embeddings: list
    average_edge_embeddings: list
    average_graph_embeddings: list
    directory_name: str
    do_hungarian: bool
    make_padding: bool
    i: int


def greedy_get_best(similarity_matrix, make_padding=True):
    """
    Greedy algorithm to find the best matching similarities.

    :param similarity_matrix: Similarity matrix.
    :type similarity_matrix: ndarray
    :param make_padding: Whether to apply padding for matrix matching.
    :type make_padding: bool
    """
    best_similarities = []
    num_rows, num_cols = similarity_matrix.shape
    for row in range(num_rows):
        max_index = np.argmax(similarity_matrix[row])
        best_similarities.append(similarity_matrix[row][max_index])
        similarity_matrix[:, max_index] = 0
        if not make_padding:
            if (row + 1) == num_cols:
                break
    return best_similarities


def hungarian_get_best(cost_matrix, make_padding=True):
    """
    The Hungarian algorithm to find the best matching similarities.

    :param cost_matrix: Cost matrix (negative similarities).
    :type cost_matrix: ndarray
    :param make_padding: Whether to apply padding for matrix matching.
    :type make_padding: bool
    :return: List of the best similarities.
    """
    best_similarities = []
    cost_row, cost_col = cost_matrix.shape
    if make_padding:
        if cost_row > cost_col:
            padding = np.zeros((cost_row, cost_row - cost_col))
            cost_matrix = np.append(cost_matrix, padding, axis=1)
    row_indices, col_indices = linear_sum_assignment(cost_matrix)
    for i in range(len(row_indices)):
        best_similarities.append(-cost_matrix[row_indices[i]][col_indices[i]])
    return best_similarities


def compute_similarities(arg: SimilarityArg):
    """
    Compute similarities between embeddings and save the results.

    :param arg: Arguments required for similarity computation.
    :type arg: SimilarityArg
    """
    print(arg.i)
    with open(os.path.join(arg.directory_name, f"results{arg.i:04d}.csv"), "w") as fout:
        for j in range(arg.i, len(arg.final_names)):
            i_rows, _ = arg.average_node_embeddings[arg.i].shape
            j_rows, _ = arg.average_node_embeddings[j].shape
            if i_rows > j_rows:
                first = arg.i
                second = j
            else:
                first = j
                second = arg.i

            node_sims = np.abs(
                cosine_similarity(arg.average_node_embeddings[first], arg.average_node_embeddings[second]))
            edge_sims = np.abs(
                cosine_similarity(arg.average_edge_embeddings[first], arg.average_edge_embeddings[second]))
            graph_sims = np.abs(
                cosine_similarity(arg.average_graph_embeddings[first], arg.average_graph_embeddings[second]))
            if arg.do_hungarian:
                node_costs = -node_sims
                node_sim = np.mean(hungarian_get_best(node_costs, make_padding=arg.make_padding))

                edge_costs = -edge_sims
                edge_sim = np.mean(hungarian_get_best(edge_costs, make_padding=arg.make_padding))

                graph_costs = -graph_sims
                graph_sim = np.mean(hungarian_get_best(graph_costs, make_padding=arg.make_padding))
            else:
                node_sim = np.mean(greedy_get_best(node_sims, make_padding=arg.make_padding))
                edge_sim = np.mean(greedy_get_best(edge_sims, make_padding=arg.make_padding))
                graph_sim = np.mean(greedy_get_best(graph_sims, make_padding=arg.make_padding))

            line = f"{arg.final_names[arg.i]},{arg.final_names[j]},{node_sim:1.3f},{edge_sim:1.3f},{graph_sim:1.3f}"
            # print(line)
            fout.write(f"{line}\n")


def main():
    """
    Main function to demonstrate the usage of similarity computation.
    In practice,  final_names should be obtained based on the names of the files to be compared.
    Node, edge, and graph embeddings should store the adequate embeddings of these files.
    :return:
    """
    final_names = ['sample1', 'sample2', 'sample3']
    average_node_embeddings = [np.random.rand(10, 64), np.random.rand(12, 64), np.random.rand(8, 64)]
    average_edge_embeddings = [np.random.rand(10, 64), np.random.rand(12, 64), np.random.rand(8, 64)]
    average_graph_embeddings = [np.random.rand(1, 64), np.random.rand(1, 64), np.random.rand(1, 64)]

    directory_name = 'results'
    if not os.path.exists(directory_name):
        os.makedirs(directory_name)

    arg = SimilarityArg(
        final_names=final_names,
        average_node_embeddings=average_node_embeddings,
        average_edge_embeddings=average_edge_embeddings,
        average_graph_embeddings=average_graph_embeddings,
        directory_name=directory_name,
        do_hungarian=False,
        make_padding=True,
        i=0
    )

    compute_similarities(arg)


if __name__ == '__main__':
    main()
